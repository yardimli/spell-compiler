<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Three.js Elemental Particle Ball</title>
	<style>
		body {
			margin: 0;
			overflow: hidden;
			background-color: #000;
		}
		canvas {
			display: block;
		}
	</style>
</head>
<body>
<script type="importmap">
	{
			"imports": {
					"three": "https://unpkg.com/three@0.163.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/",
					"lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.js"
			}
	}
</script>

<script type="module">
	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
	import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
	import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
	import GUI from 'lil-gui';
	
	// --- Configuration ---
	const CONFIG = {
		particleCount: 25000,
		sphereRadius: 10,
		starCount: 15000,
		colorPreset: 'Water', // Options: 'Water', 'Fire', 'Earth', 'Air'
		bloom: {
			strength: 1.3,
			radius: 0.5,
			threshold: 0.05,
		},
		noise: {
			amount: 0.1,
			speed: 0.2,
		},
		ballMovement: {
			amplitude: 2.5,
			speed: 0.3
		},
		colorAnimation: {
			enabled: true,
			speed: 0.05
		}
	};
	
	// --- Color presets for different themes ---
	const COLOR_PRESETS = {
		'Fire':  { hueStart: 0.0, hueEnd: 0.1, saturation: 1.0, lightness: 0.55 },
		'Water': { hueStart: 0.55, hueEnd: 0.7, saturation: 1.0, lightness: 0.6 },
		'Earth': { hueStart: 0.1, hueEnd: 0.35, saturation: 0.6, lightness: 0.45 },
		'Air':   { hueStart: 0.5, hueEnd: 0.6, saturation: 0.2, lightness: 0.8 }
	};
	
	// --- (START) NEW: SHADER DEFINITIONS FOR EACH ELEMENT ---
	
	// --- Shared GLSL Functions ---
	const GLSL_UTILS = `
		// HSL to RGB conversion function
		vec3 hsl2rgb(vec3 c) {
			vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);
			return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
		}

		// Classic 3D Perlin Noise function
		vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
		vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
		vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
		float cnoise(vec3 P){
			vec3 Pi0 = floor(P); vec3 Pi1 = Pi0 + vec3(1.0); Pi0 = mod(Pi0, 289.0); Pi1 = mod(Pi1, 289.0);
			vec3 Pf0 = fract(P); vec3 Pf1 = Pf0 - vec3(1.0);
			vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x); vec4 iy = vec4(Pi0.yy, Pi1.yy);
			vec4 iz0 = Pi0.zzzz; vec4 iz1 = Pi1.zzzz;
			vec4 ixy = permute(permute(ix) + iy);
			vec4 ixy0 = permute(ixy + iz0); vec4 ixy1 = permute(ixy + iz1);
			vec4 gx0 = ixy0 / 7.0; vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5; gx0 = fract(gx0);
			vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0); vec4 sz0 = step(gz0, vec4(0.0));
			gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
			vec4 gx1 = ixy1 / 7.0; vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5; gx1 = fract(gx1);
			vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1); vec4 sz1 = step(gz1, vec4(0.0));
			gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
			vec3 g000 = vec3(gx0.x,gy0.x,gz0.x); vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
			vec3 g010 = vec3(gx0.z,gy0.z,gz0.z); vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
			vec3 g001 = vec3(gx1.x,gy1.x,gz1.x); vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
			vec3 g011 = vec3(gx1.z,gy1.z,gz1.z); vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
			vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
			g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w;
			vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
			g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w;
			float n000 = dot(g000, Pf0); float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
			float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z)); float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
			float n001 = dot(g001, vec3(Pf0.xy, Pf1.z)); float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
			float n011 = dot(g011, vec3(Pf0.x, Pf1.yz)); float n111 = dot(g111, Pf1);
			vec3 fade_xyz = fade(Pf0);
			vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
			vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
			float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
			return 2.2 * n_xyz;
		}
	`;
	
	const ELEMENT_SHADERS = {
		'Fire': {
			vertex: `
				attribute float size;
				varying vec3 vColor;
				
				uniform float uTime;
				uniform float uNoiseAmount;
				uniform float uNoiseSpeed;
				uniform float uSphereRadius;
				uniform float uHueStart;
				uniform float uHueEnd;
				uniform float uSaturation;
				uniform float uLightness;
				uniform float uColorShiftSpeed;

				${GLSL_UTILS}

				void main() {
					vec3 normal = normalize(position);
					float y_norm = (normal.y + 1.0) / 2.0;
					
					// --- Color: Flickering fire ---
					float flicker = cnoise(normal * 10.0 + uTime * uNoiseSpeed * 8.0) * 0.5 + 0.5; // Fast flicker
					float hue = mix(uHueStart, uHueEnd, y_norm);
					hue = mod(hue + uTime * uColorShiftSpeed, 1.0);
					float lightness = uLightness + (flicker * 0.3) - (y_norm * 0.2);
					vColor = hsl2rgb(vec3(hue, uSaturation, lightness));

					// --- Displacement: Rising flames ---
					vec3 transformed = position;
					vec3 noise_coord = normal * 2.0 + vec3(0.0, -uTime * uNoiseSpeed * 0.5, 0.0); // Noise moves upwards
					float noise = cnoise(noise_coord);
					noise += cnoise(noise_coord * 3.0) * 0.5;
					transformed += normal * noise * uNoiseAmount * (y_norm + 0.5); // More displacement at top
					
					vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);
					gl_PointSize = size * (400.0 / -mvPosition.z) * (1.0 - y_norm * 0.5); // Smaller particles at top
					gl_Position = projectionMatrix * mvPosition;
				}
			`,
			fragment: `
				uniform sampler2D pointTexture;
				varying vec3 vColor;
				void main() {
					float alpha = texture2D(pointTexture, gl_PointCoord).a;
					if (alpha < 0.05) discard;
					gl_FragColor = vec4(vColor, alpha);
				}
			`
		},
		'Water': {
			vertex: `
				attribute float size;
				varying vec3 vColor;
				
				uniform float uTime;
				uniform float uNoiseAmount;
				uniform float uNoiseSpeed;
				uniform float uSphereRadius;
				uniform float uHueStart;
				uniform float uHueEnd;
				uniform float uSaturation;
				uniform float uLightness;
				uniform float uColorShiftSpeed;

				${GLSL_UTILS}

				void main() {
					// --- Color: Standard gradient ---
					float y_norm = (position.y / uSphereRadius + 1.0) / 2.0;
					float hue = mix(uHueStart, uHueEnd, y_norm);
					hue = mod(hue + uTime * uColorShiftSpeed, 1.0);
					vColor = hsl2rgb(vec3(hue, uSaturation, uLightness));

					// --- Displacement: Swirling currents ---
					vec3 transformed = position;
					vec3 normal = normalize(position);
					float noise = cnoise(normal * 1.5 + uTime * uNoiseSpeed);
					noise += cnoise(normal * 4.0 + uTime * uNoiseSpeed * 1.5) * 0.5; // Second layer for detail
					transformed += normal * noise * uNoiseAmount;
					
					vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);
					gl_PointSize = size * (400.0 / -mvPosition.z);
					gl_Position = projectionMatrix * mvPosition;
				}
			`,
			fragment: `
				uniform sampler2D pointTexture;
				varying vec3 vColor;
				void main() {
					float alpha = texture2D(pointTexture, gl_PointCoord).a;
					if (alpha < 0.05) discard;
					gl_FragColor = vec4(vColor, alpha);
				}
			`
		},
		'Earth': {
			vertex: `
				attribute float size;
				varying vec3 vColor;
				
				uniform float uTime;
				uniform float uNoiseAmount;
				uniform float uNoiseSpeed;
				uniform float uSphereRadius;
				uniform float uHueStart;
				uniform float uHueEnd;
				uniform float uSaturation;
				uniform float uLightness;
				uniform float uColorShiftSpeed;

				${GLSL_UTILS}

				void main() {
					vec3 normal = normalize(position);
					
					// --- Displacement: Crystalline, terraced forms ---
					float slowTime = uTime * uNoiseSpeed * 0.1; // Much slower animation
					float terraceNoise = cnoise(normal * 2.5 + slowTime);
					// Quantize the noise to create sharp steps/terraces
					float terraces = floor(terraceNoise * 5.0) / 5.0;
					vec3 transformed = position + normal * terraces * uNoiseAmount * 3.0;

					// --- Color: Banded based on terraces ---
					float colorNoise = (cnoise(normal * 1.5 + slowTime * uColorShiftSpeed) + 1.0) / 2.0;
					float hue = mix(uHueStart, uHueEnd, colorNoise);
					vColor = hsl2rgb(vec3(hue, uSaturation, uLightness));
					
					vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);
					gl_PointSize = size * (400.0 / -mvPosition.z);
					gl_Position = projectionMatrix * mvPosition;
				}
			`,
			fragment: `
				uniform sampler2D pointTexture;
				varying vec3 vColor;
				void main() {
					float alpha = texture2D(pointTexture, gl_PointCoord).a;
					if (alpha < 0.05) discard;
					gl_FragColor = vec4(vColor, alpha);
				}
			`
		},
		'Air': {
			vertex: `
				attribute float size;
				varying vec3 vColor;
				varying float vAlpha; // Pass alpha to fragment shader
				
				uniform float uTime;
				uniform float uNoiseAmount;
				uniform float uNoiseSpeed;
				uniform float uSphereRadius;
				uniform float uHueStart;
				uniform float uHueEnd;
				uniform float uSaturation;
				uniform float uLightness;
				uniform float uColorShiftSpeed;

				${GLSL_UTILS}

				void main() {
					vec3 normal = normalize(position);
					
					// --- Displacement: Soft, wispy clouds ---
					vec3 transformed = position;
					float noise = cnoise(normal * 0.8 + uTime * uNoiseSpeed * 0.2); // Low frequency noise
					noise += cnoise(normal * 2.5 + uTime * uNoiseSpeed * 0.5) * 0.3;
					transformed += normal * noise * uNoiseAmount;

					// --- Color & Alpha: Ethereal and transparent ---
					float alphaNoise = (cnoise(normal * 1.5 + uTime * uNoiseSpeed * 0.4) + 1.0) / 2.0;
					vAlpha = pow(alphaNoise, 2.5); // Use pow to create more contrast in transparency

					float hue = mix(uHueStart, uHueEnd, (normal.y + 1.0) / 2.0);
					hue = mod(hue + uTime * uColorShiftSpeed, 1.0);
					vColor = hsl2rgb(vec3(hue, uSaturation, uLightness));
					
					vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);
					gl_PointSize = size * (400.0 / -mvPosition.z) * 1.5; // Slightly larger particles
					gl_Position = projectionMatrix * mvPosition;
				}
			`,
			fragment: `
				uniform sampler2D pointTexture;
				varying vec3 vColor;
				varying float vAlpha;
				void main() {
					float textureAlpha = texture2D(pointTexture, gl_PointCoord).a;
					if (textureAlpha * vAlpha < 0.02) discard;
					gl_FragColor = vec4(vColor, textureAlpha * vAlpha);
				}
			`
		}
	};
	// --- (END) NEW: SHADER DEFINITIONS ---
	
	
	// --- Scene Setup ---
	const scene = new THREE.Scene();
	const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
	camera.position.z = 30;
	
	const renderer = new THREE.WebGLRenderer({ antialias: true });
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.toneMapping = THREE.ACESFilmicToneMapping;
	document.body.appendChild(renderer.domElement);
	
	// --- Post-processing (for Glow Effect) ---
	const composer = new EffectComposer(renderer);
	composer.addPass(new RenderPass(scene, camera));
	const bloomPass = new UnrealBloomPass(
		new THREE.Vector2(window.innerWidth, window.innerHeight),
		CONFIG.bloom.strength,
		CONFIG.bloom.radius,
		CONFIG.bloom.threshold
	);
	composer.addPass(bloomPass);
	
	// --- Reusable Texture Function ---
	function createParticleTexture() {
		const size = 64;
		const canvas = document.createElement('canvas');
		canvas.width = size;
		canvas.height = size;
		const context = canvas.getContext('2d');
		const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
		gradient.addColorStop(0, 'rgba(255,255,255,1)');
		gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
		gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)');
		gradient.addColorStop(1, 'rgba(255,255,255,0)');
		context.fillStyle = gradient;
		context.fillRect(0, 0, size, size);
		return new THREE.CanvasTexture(canvas);
	}
	const particleTexture = createParticleTexture();
	
	// --- 1. Create the Starfield Background ---
	function createStarfield() {
		const starVertices = [];
		const starColors = [];
		const starSizes = [];
		const tempVec = new THREE.Vector3();
		
		for (let i = 0; i < CONFIG.starCount; i++) {
			tempVec.set(
				THREE.MathUtils.randFloatSpread(400),
				THREE.MathUtils.randFloatSpread(400),
				THREE.MathUtils.randFloatSpread(400)
			);
			if (tempVec.length() < 80) {
				tempVec.setLength(80 + Math.random() * 200);
			}
			starVertices.push(tempVec.x, tempVec.y, tempVec.z);
			starSizes.push(Math.random() * 0.2 + 0.05);
			
			const color = new THREE.Color();
			if (Math.random() < 0.1) {
				color.setHSL(Math.random(), 0.7, 0.65);
			} else {
				color.setHSL(0.6, Math.random() * 0.1, 0.8 + Math.random() * 0.2);
			}
			starColors.push(color.r, color.g, color.b);
		}
		
		const starGeometry = new THREE.BufferGeometry();
		starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
		starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
		starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
		
		const starMaterial = new THREE.ShaderMaterial({
			uniforms: { pointTexture: { value: particleTexture } },
			vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (400.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }`,
			fragmentShader: `
                    uniform sampler2D pointTexture;
                    varying vec3 vColor;
                    void main() {
                        float alpha = texture2D(pointTexture, gl_PointCoord).a;
                        if (alpha < 0.1) discard;
                        gl_FragColor = vec4(vColor, alpha * 0.9);
                    }`,
			blending: THREE.AdditiveBlending,
			depthWrite: false,
			transparent: true,
			vertexColors: true
		});
		
		const starfield = new THREE.Points(starGeometry, starMaterial);
		scene.add(starfield);
	}
	createStarfield();
	
	// --- 2. Create the Checkered Floor ---
	let floor;
	function createCheckeredFloor() {
		const canvas = document.createElement('canvas');
		const context = canvas.getContext('2d');
		canvas.width = 2;
		canvas.height = 2;
		
		context.fillStyle = '#1a1a1a';
		context.fillRect(0, 0, 2, 2);
		context.fillStyle = '#101010';
		context.fillRect(0, 0, 1, 1);
		context.fillRect(1, 1, 1, 1);
		
		const floorTexture = new THREE.CanvasTexture(canvas);
		floorTexture.wrapS = THREE.RepeatWrapping;
		floorTexture.wrapT = THREE.RepeatWrapping;
		floorTexture.magFilter = THREE.NearestFilter;
		floorTexture.repeat.set(50, 50);
		
		const floorGeometry = new THREE.PlaneGeometry(200, 200);
		const floorMaterial = new THREE.MeshBasicMaterial({
			map: floorTexture,
			side: THREE.DoubleSide
		});
		
		floor = new THREE.Mesh(floorGeometry, floorMaterial);
		floor.rotation.x = -Math.PI / 2;
		updateFloorPosition();
		scene.add(floor);
	}
	
	function updateFloorPosition() {
		if (floor) {
			floor.position.y = -CONFIG.sphereRadius - 5;
		}
	}
	createCheckeredFloor();
	
	
	// --- MODIFIED --- 3. Create the Particle Ball (now with shader-based colors) ---
	let particleBall, particleMaterial;
	
	function regenerateParticleBall() {
		if (particleBall) {
			particleBall.geometry.dispose();
			particleBall.material.dispose();
			scene.remove(particleBall);
		}
		
		const geometry = new THREE.BufferGeometry();
		const positions = new Float32Array(CONFIG.particleCount * 3);
		const sizes = new Float32Array(CONFIG.particleCount);
		
		const tempVec = new THREE.Vector3();
		const preset = COLOR_PRESETS[CONFIG.colorPreset];
		// --- NEW --- Get the correct shader for the current preset
		const shaders = ELEMENT_SHADERS[CONFIG.colorPreset];
		
		for (let i = 0; i < CONFIG.particleCount; i++) {
			tempVec.set(
				THREE.MathUtils.randFloatSpread(2),
				THREE.MathUtils.randFloatSpread(2),
				THREE.MathUtils.randFloatSpread(2)
			).normalize().multiplyScalar(CONFIG.sphereRadius);
			
			positions[i * 3] = tempVec.x;
			positions[i * 3 + 1] = tempVec.y;
			positions[i * 3 + 2] = tempVec.z;
			
			sizes[i] = Math.random() * 0.15 + 0.05;
		}
		
		geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
		geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
		
		// --- MODIFIED --- Material now uses the selected shader and all necessary uniforms
		particleMaterial = new THREE.ShaderMaterial({
			uniforms: {
				pointTexture: { value: particleTexture },
				uTime: { value: 0.0 },
				uNoiseAmount: { value: CONFIG.noise.amount },
				uNoiseSpeed: { value: CONFIG.noise.speed },
				uSphereRadius: { value: CONFIG.sphereRadius },
				uHueStart: { value: preset.hueStart },
				uHueEnd: { value: preset.hueEnd },
				uSaturation: { value: preset.saturation },
				uLightness: { value: preset.lightness },
				uColorShiftSpeed: { value: CONFIG.colorAnimation.enabled ? CONFIG.colorAnimation.speed : 0.0 }
			},
			vertexShader: shaders.vertex,
			fragmentShader: shaders.fragment,
			blending: THREE.AdditiveBlending,
			depthWrite: false,
			transparent: true,
		});
		
		particleBall = new THREE.Points(geometry, particleMaterial);
		scene.add(particleBall);
	}
	
	// --- Initial creation of the particle ball ---
	regenerateParticleBall();
	
	// --- GUI for real-time control ---
	const gui = new GUI();
	
	const ballFolder = gui.addFolder('Particle Ball');
	ballFolder.add(CONFIG, 'particleCount', 5000, 50000, 1000)
		.name('Particle Count')
		.onFinishChange(regenerateParticleBall);
	ballFolder.add(CONFIG, 'sphereRadius', 1, 20, 0.1)
		.name('Radius')
		.onFinishChange(() => {
			updateFloorPosition();
			regenerateParticleBall();
		});
	ballFolder.add(CONFIG, 'colorPreset', Object.keys(COLOR_PRESETS))
		.name('Element')
		.onChange(regenerateParticleBall); // This now swaps the shaders
	
	const colorFolder = gui.addFolder('Color Animation');
	colorFolder.add(CONFIG.colorAnimation, 'enabled').name('Animate Colors').onChange(val => {
		if (particleMaterial) {
			particleMaterial.uniforms.uColorShiftSpeed.value = val ? CONFIG.colorAnimation.speed : 0.0;
		}
	});
	colorFolder.add(CONFIG.colorAnimation, 'speed', 0, 0.5, 0.01).name('Animation Speed').onChange(val => {
		if (particleMaterial && CONFIG.colorAnimation.enabled) {
			particleMaterial.uniforms.uColorShiftSpeed.value = val;
		}
	});
	
	const noiseFolder = gui.addFolder('Organic Movement (Surface)');
	noiseFolder.add(CONFIG.noise, 'amount', 0, 5, 0.01).name('Amount').onChange(val => {
		if (particleMaterial) particleMaterial.uniforms.uNoiseAmount.value = val;
	});
	noiseFolder.add(CONFIG.noise, 'speed', 0, 1, 0.01).name('Speed').onChange(val => {
		if (particleMaterial) particleMaterial.uniforms.uNoiseSpeed.value = val;
	});
	
	const movementFolder = gui.addFolder('Global Movement (Drift)');
	movementFolder.add(CONFIG.ballMovement, 'amplitude', 0, 10, 0.1).name('Distance');
	movementFolder.add(CONFIG.ballMovement, 'speed', 0, 2, 0.01).name('Speed');
	
	const bloomFolder = gui.addFolder('Glow (Bloom)');
	bloomFolder.add(CONFIG.bloom, 'strength', 0, 3, 0.01).name('Strength').onChange(val => bloomPass.strength = val);
	bloomFolder.add(CONFIG.bloom, 'radius', 0, 2, 0.01).name('Radius').onChange(val => bloomPass.radius = val);
	bloomFolder.add(CONFIG.bloom, 'threshold', 0, 1, 0.01).name('Threshold').onChange(val => bloomPass.threshold = val);
	
	
	// --- Controls & Animation ---
	const controls = new OrbitControls(camera, renderer.domElement);
	controls.enableDamping = true;
	controls.dampingFactor = 0.05;
	controls.minDistance = 15;
	controls.maxDistance = 100;
	controls.target.set(0, 0, 0);
	
	const clock = new THREE.Clock();
	
	function animate() {
		requestAnimationFrame(animate);
		const elapsedTime = clock.getElapsedTime();
		
		if (particleBall && particleMaterial) {
			particleMaterial.uniforms.uTime.value = elapsedTime;
			
			const moveSpeed = CONFIG.ballMovement.speed;
			const moveAmplitude = CONFIG.ballMovement.amplitude;
			particleBall.position.x = Math.sin(elapsedTime * moveSpeed) * moveAmplitude;
			particleBall.position.y = Math.sin(elapsedTime * moveSpeed * 0.8) * moveAmplitude * 0.4;
			particleBall.position.z = Math.cos(elapsedTime * moveSpeed * 1.2) * moveAmplitude;
			
			particleBall.rotation.y = elapsedTime * 0.05;
		}
		
		controls.update();
		composer.render();
	}
	
	// --- Handle Window Resizing ---
	window.addEventListener('resize', () => {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
		composer.setSize(window.innerWidth, window.innerHeight);
		renderer.setPixelRatio(window.devicePixelRatio);
	});
	
	animate();
</script>
</body>
</html>

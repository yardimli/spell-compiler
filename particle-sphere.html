<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Three.js Elemental Particle Ball</title>
	<style>
		body {
			margin: 0;
			overflow: hidden;
			background-color: #000;
		}
		canvas {
			display: block;
		}
	</style>
</head>
<body>
<script type="importmap">
	{
			"imports": {
					"three": "https://unpkg.com/three@0.163.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/",
					"lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.js"
			}
	}
</script>

<script type="module">
	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
	import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
	import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
	import GUI from 'lil-gui';
	
	// --- Configuration ---
	const CONFIG = {
		particleCount: 25000,
		sphereRadius: 10,
		starCount: 15000,
		colorPreset: 'Fire', // Options: 'Water', 'Fire', 'Earth', 'Air'
		bloom: {
			strength: 1.3,
			radius: 0.5,
			threshold: 0.05,
		},
		noise: {
			amount: 0.1,
			speed: 0.2,
		},
		ballMovement: {
			amplitude: 2.5,
			speed: 0.3
		},
		// --- (MODIFIED) Interaction and Explosion configuration ---
		flightSpeed: 4.0, // Speed of ball moving to target
		explosion: {
			duration: 2.0,      // seconds
			strength: 60.0,
			gravity: 40.0,
			variance: 1.5,      // Randomness of particle explosion speed
			fadeVariance: 0.4   // Randomness of particle fade-out time
		}
	};
	
	// --- Color presets for different themes using RGB hex codes ---
	const COLOR_PRESETS = {
		'Fire':  { primary: '#FF4500', accent: '#FFD700', glow: '#FFFFFF' },
		'Water': { primary: '#1E90FF', accent: '#40E0D0', glow: '#AFEEEE' },
		'Earth': { primary: '#7B3F00', accent: '#228B22', glow: '#A0522D' },
		'Air':   { primary: '#AEE6F5', accent: '#F0F8FF', glow: '#CFFAFE' }
	};
	
	// --- SHADER DEFINITIONS ---
	
	// --- Shared GLSL Functions ---
	const GLSL_UTILS = `
		// Classic 3D Perlin Noise function
		vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
		vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
		vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
		float cnoise(vec3 P){
			vec3 Pi0 = floor(P); vec3 Pi1 = Pi0 + vec3(1.0); Pi0 = mod(Pi0, 289.0); Pi1 = mod(Pi1, 289.0);
			vec3 Pf0 = fract(P); vec3 Pf1 = Pf0 - vec3(1.0);
			vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x); vec4 iy = vec4(Pi0.yy, Pi1.yy);
			vec4 iz0 = Pi0.zzzz; vec4 iz1 = Pi1.zzzz;
			vec4 ixy = permute(permute(ix) + iy);
			vec4 ixy0 = permute(ixy + iz0); vec4 ixy1 = permute(ixy + iz1);
			vec4 gx0 = ixy0 / 7.0; vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5; gx0 = fract(gx0);
			vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0); vec4 sz0 = step(gz0, vec4(0.0));
			gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
			vec4 gx1 = ixy1 / 7.0; vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5; gx1 = fract(gx1);
			vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1); vec4 sz1 = step(gz1, vec4(0.0));
			gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
			vec3 g000 = vec3(gx0.x,gy0.x,gz0.x); vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
			vec3 g010 = vec3(gx0.z,gy0.z,gz0.z); vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
			vec3 g001 = vec3(gx1.x,gy1.x,gz1.x); vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
			vec3 g011 = vec3(gx1.z,gy1.z,gz1.z); vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
			vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
			g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w;
			vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
			g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w;
			float n000 = dot(g000, Pf0); float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
			float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z)); float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
			float n001 = dot(g001, vec3(Pf0.xy, Pf1.z)); float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
			float n011 = dot(g011, vec3(Pf0.x, Pf1.yz)); float n111 = dot(g111, Pf1);
			vec3 fade_xyz = fade(Pf0);
			vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
			vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
			float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
			return 2.2 * n_xyz;
		}
	`;
	
	// --- (MODIFIED) Shared explosion logic for vertex shaders ---
	const GLSL_EXPLOSION_LOGIC = `
		attribute float aRandom;
		uniform float uExplosionProgress;
		uniform float uExplosionStrength;
		uniform float uExplosionGravity;
		uniform float uExplosionVariance;
		varying float vExplosionProgress;
		varying float vRandom;

		vec3 getExplosionPosition(vec3 basePosition) {
			vExplosionProgress = uExplosionProgress;
			vRandom = aRandom;
			if (uExplosionProgress > 0.0) {
				vec3 explosionDir = normalize(position); // Use original sphere position for a clean radial direction
				float speed = 1.0 + aRandom * uExplosionVariance;
				float distance = pow(uExplosionProgress, 1.5) * uExplosionStrength * speed;
				
				// <<< FIXED: Start from the noise-deformed 'basePosition', not the raw 'position'
				vec3 newPos = basePosition + explosionDir * distance;
				
				// Apply gravity
				newPos.y -= pow(uExplosionProgress, 2.0) * uExplosionGravity * (1.0 + aRandom * uExplosionVariance * 0.5);
				return newPos;
			}
			return basePosition;
		}
	`;
	
	// --- (MODIFIED) Shared fade logic for fragment shaders ---
	const GLSL_FADE_LOGIC = `
		varying float vExplosionProgress;
		varying float vRandom;
		uniform float uFadeVariance;

		float getFadeAlpha(float initialAlpha) {
			float baseFadeDuration = 0.5;
			// Randomize the duration of the fade-out. Higher variance = more difference.
			float randomizedDuration = baseFadeDuration - vRandom * uFadeVariance;
			randomizedDuration = max(0.1, randomizedDuration); // Ensure it doesn't become zero or negative

			float fadeStart = 0.4;
			float fade = 1.0 - smoothstep(fadeStart, fadeStart + randomizedDuration, vExplosionProgress);
			return initialAlpha * fade;
		}
	`;
	
	const ELEMENT_SHADERS = {
		'Fire': {
			vertex: `
				attribute float size;
				varying vec3 vColor;
				uniform float uTime;
				uniform float uNoiseAmount;
				uniform float uNoiseSpeed;
				uniform vec3 uColorPrimary;
				uniform vec3 uColorAccent;
				uniform vec3 uColorGlow;
				${GLSL_UTILS}
				${GLSL_EXPLOSION_LOGIC}

				void main() {
					vec3 normal = normalize(position);
					float y_norm = (normal.y + 1.0) / 2.0;
					float flicker_fast = cnoise(normal * 15.0 + uTime * uNoiseSpeed * 10.0);
					float flicker_slow = cnoise(normal * 5.0 + uTime * uNoiseSpeed * 3.0);
					vec3 baseColor = mix(uColorPrimary, uColorAccent, smoothstep(0.0, 0.6, flicker_fast));
					float glow_amount = smoothstep(0.5, 0.8, flicker_slow);
					vColor = mix(baseColor, uColorGlow, glow_amount);

					vec3 transformed = position;
					vec3 noise_coord = normal * 2.0 + vec3(0.0, -uTime * uNoiseSpeed * 0.5, 0.0);
					float noise = cnoise(noise_coord) + cnoise(noise_coord * 3.0) * 0.5;
					transformed += normal * noise * uNoiseAmount * (y_norm + 0.5);
					
					vec3 finalPos = getExplosionPosition(transformed);
					
					vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
					gl_PointSize = size * (400.0 / -mvPosition.z) * (1.0 - y_norm * 0.5) * (1.0 + glow_amount);
					gl_Position = projectionMatrix * mvPosition;
				}
			`,
			fragment: `
				uniform sampler2D pointTexture;
				varying vec3 vColor;
				${GLSL_FADE_LOGIC}
				void main() {
					float alpha = texture2D(pointTexture, gl_PointCoord).a;
					alpha = getFadeAlpha(alpha);
					if (alpha < 0.02) discard;
					gl_FragColor = vec4(vColor, alpha);
				}
			`
		},
		'Water': {
			vertex: `
				attribute float size;
				varying vec3 vColor;
				uniform float uTime;
				uniform float uNoiseAmount;
				uniform float uNoiseSpeed;
				uniform vec3 uColorPrimary;
				uniform vec3 uColorAccent;
				uniform vec3 uColorGlow;
				${GLSL_UTILS}
				${GLSL_EXPLOSION_LOGIC}

				void main() {
					float color_noise = (cnoise(position * 0.5 + uTime * 0.1) + 1.0) * 0.5;
					vec3 baseColor = mix(uColorPrimary, uColorAccent, color_noise);
					vec3 caustic_coord = position * 2.0 + vec3(0.0, uTime * uNoiseSpeed * 2.0, uTime * uNoiseSpeed * 1.5);
					float caustic_noise = cnoise(caustic_coord) + cnoise(caustic_coord * 2.5) * 0.5;
					float caustic_glow = pow(smoothstep(0.4, 0.7, caustic_noise), 2.0);
					vColor = mix(baseColor, uColorGlow, caustic_glow);

					vec3 transformed = position;
					vec3 normal = normalize(position);
					float noise = cnoise(normal * 1.5 + uTime * uNoiseSpeed) + cnoise(normal * 4.0 + uTime * uNoiseSpeed * 1.5) * 0.5;
					transformed += normal * noise * uNoiseAmount;
					
					vec3 finalPos = getExplosionPosition(transformed);

					vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
					gl_PointSize = size * (400.0 / -mvPosition.z) * (1.0 + caustic_glow * 0.5);
					gl_Position = projectionMatrix * mvPosition;
				}
			`,
			fragment: `
				uniform sampler2D pointTexture;
				varying vec3 vColor;
				${GLSL_FADE_LOGIC}
				void main() {
					float alpha = texture2D(pointTexture, gl_PointCoord).a;
					alpha = getFadeAlpha(alpha);
					if (alpha < 0.02) discard;
					gl_FragColor = vec4(vColor, alpha);
				}
			`
		},
		'Earth': {
			vertex: `
				attribute float size;
				varying vec3 vColor;
				uniform float uTime;
				uniform float uNoiseAmount;
				uniform float uNoiseSpeed;
				uniform vec3 uColorPrimary;
				uniform vec3 uColorAccent;
				uniform vec3 uColorGlow;
				${GLSL_UTILS}
				${GLSL_EXPLOSION_LOGIC}

				void main() {
					vec3 normal = normalize(position);
					float slowTime = uTime * uNoiseSpeed * 0.1;
					float terraceNoise = cnoise(normal * 2.5 + slowTime);
					float terraces = floor(terraceNoise * 5.0) / 5.0;
					float crackleNoise = cnoise(position * 30.0 + slowTime);
					vec3 transformed = position + normal * (terraces * uNoiseAmount * 3.0 + crackleNoise * uNoiseAmount * 0.3);

					float colorNoise = (cnoise(normal * 1.5 + slowTime * 0.5) + 1.0) / 2.0;
					vec3 baseColor = mix(uColorPrimary, uColorAccent, smoothstep(0.4, 0.6, colorNoise));
					float glowNoise = smoothstep(0.6, 0.8, cnoise(normal * 4.0 + slowTime));
					vColor = mix(baseColor, uColorGlow, glowNoise * 0.5);
					
					vec3 finalPos = getExplosionPosition(transformed);
					
					vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
					gl_PointSize = size * (400.0 / -mvPosition.z);
					gl_Position = projectionMatrix * mvPosition;
				}
			`,
			fragment: `
				uniform sampler2D pointTexture;
				varying vec3 vColor;
				${GLSL_FADE_LOGIC}
				void main() {
					float alpha = texture2D(pointTexture, gl_PointCoord).a;
					alpha = getFadeAlpha(alpha);
					if (alpha < 0.02) discard;
					gl_FragColor = vec4(vColor, alpha);
				}
			`
		},
		'Air': {
			vertex: `
				attribute float size;
				varying vec3 vColor;
				varying float vAlpha;
				uniform float uTime;
				uniform float uNoiseAmount;
				uniform float uNoiseSpeed;
				uniform vec3 uColorPrimary;
				uniform vec3 uColorAccent;
				uniform vec3 uColorGlow;
				${GLSL_UTILS}
				${GLSL_EXPLOSION_LOGIC}

				void main() {
					vec3 normal = normalize(position);
					vec3 transformed = position;
					float noise = cnoise(normal * 0.8 + uTime * uNoiseSpeed * 0.2) + cnoise(normal * 2.5 + uTime * uNoiseSpeed * 0.5) * 0.3;
					transformed += normal * noise * uNoiseAmount;

					float colorNoise = (cnoise(normal * 2.0 + uTime * uNoiseSpeed * 0.3) + 1.0) / 2.0;
					vec3 baseColor = mix(uColorPrimary, uColorAccent, colorNoise);
					float glowNoise = (cnoise(normal * 0.8 + uTime * uNoiseSpeed * 0.2) + 1.0) / 2.0;
					float glowAmount = pow(glowNoise, 3.0);
					vColor = mix(baseColor, uColorGlow, glowAmount);
					
					float alphaNoise = (cnoise(normal * 1.5 + uTime * uNoiseSpeed * 0.4) + 1.0) / 2.0;
					vAlpha = pow(alphaNoise, 2.5);
					
					vec3 finalPos = getExplosionPosition(transformed);
					
					vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
					gl_PointSize = size * (400.0 / -mvPosition.z) * 1.5;
					gl_Position = projectionMatrix * mvPosition;
				}
			`,
			fragment: `
				uniform sampler2D pointTexture;
				varying vec3 vColor;
				varying float vAlpha;
				${GLSL_FADE_LOGIC}
				void main() {
					float textureAlpha = texture2D(pointTexture, gl_PointCoord).a;
					float initialAlpha = textureAlpha * vAlpha;
					float finalAlpha = getFadeAlpha(initialAlpha);
					if (finalAlpha < 0.01) discard;
					gl_FragColor = vec4(vColor, finalAlpha);
				}
			`
		}
	};
	
	let flightStart = null;
	let flightStartPosition = new THREE.Vector3();
	
	// --- Scene Setup ---
	const scene = new THREE.Scene();
	const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
	camera.position.z = 30;
	
	const renderer = new THREE.WebGLRenderer({ antialias: true });
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.toneMapping = THREE.ACESFilmicToneMapping;
	document.body.appendChild(renderer.domElement);
	
	// --- Post-processing (for Glow Effect) ---
	const composer = new EffectComposer(renderer);
	composer.addPass(new RenderPass(scene, camera));
	const bloomPass = new UnrealBloomPass(
		new THREE.Vector2(window.innerWidth, window.innerHeight),
		CONFIG.bloom.strength,
		CONFIG.bloom.radius,
		CONFIG.bloom.threshold
	);
	composer.addPass(bloomPass);
	
	// --- Reusable Texture Function ---
	function createParticleTexture() {
		const size = 64;
		const canvas = document.createElement('canvas');
		canvas.width = size;
		canvas.height = size;
		const context = canvas.getContext('2d');
		const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
		gradient.addColorStop(0, 'rgba(255,255,255,1)');
		gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
		gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)');
		gradient.addColorStop(1, 'rgba(255,255,255,0)');
		context.fillStyle = gradient;
		context.fillRect(0, 0, size, size);
		return new THREE.CanvasTexture(canvas);
	}
	const particleTexture = createParticleTexture();
	
	// --- 1. Create the Starfield Background ---
	function createStarfield() {
		const starVertices = [];
		const starColors = [];
		const starSizes = [];
		const tempVec = new THREE.Vector3();
		
		for (let i = 0; i < CONFIG.starCount; i++) {
			tempVec.set(
				THREE.MathUtils.randFloatSpread(400),
				THREE.MathUtils.randFloatSpread(400),
				THREE.MathUtils.randFloatSpread(400)
			);
			if (tempVec.length() < 80) {
				tempVec.setLength(80 + Math.random() * 200);
			}
			starVertices.push(tempVec.x, tempVec.y, tempVec.z);
			starSizes.push(Math.random() * 0.2 + 0.05);
			
			const color = new THREE.Color();
			if (Math.random() < 0.1) {
				color.setHSL(Math.random(), 0.7, 0.65);
			} else {
				color.setHSL(0.6, Math.random() * 0.1, 0.8 + Math.random() * 0.2);
			}
			starColors.push(color.r, color.g, color.b);
		}
		
		const starGeometry = new THREE.BufferGeometry();
		starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
		starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
		starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
		
		const starMaterial = new THREE.ShaderMaterial({
			uniforms: { pointTexture: { value: particleTexture } },
			vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (400.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }`,
			fragmentShader: `
                    uniform sampler2D pointTexture;
                    varying vec3 vColor;
                    void main() {
                        float alpha = texture2D(pointTexture, gl_PointCoord).a;
                        if (alpha < 0.1) discard;
                        gl_FragColor = vec4(vColor, alpha * 0.9);
                    }`,
			blending: THREE.AdditiveBlending,
			depthWrite: false,
			transparent: true,
			vertexColors: true
		});
		
		const starfield = new THREE.Points(starGeometry, starMaterial);
		scene.add(starfield);
	}
	createStarfield();
	
	// --- 2. Create the Checkered Floor ---
	let floor;
	function createCheckeredFloor() {
		const canvas = document.createElement('canvas');
		const context = canvas.getContext('2d');
		canvas.width = 2;
		canvas.height = 2;
		
		context.fillStyle = '#1a1a1a';
		context.fillRect(0, 0, 2, 2);
		context.fillStyle = '#101010';
		context.fillRect(0, 0, 1, 1);
		context.fillRect(1, 1, 1, 1);
		
		const floorTexture = new THREE.CanvasTexture(canvas);
		floorTexture.wrapS = THREE.RepeatWrapping;
		floorTexture.wrapT = THREE.RepeatWrapping;
		floorTexture.magFilter = THREE.NearestFilter;
		floorTexture.repeat.set(50, 50);
		
		const floorGeometry = new THREE.PlaneGeometry(200, 200);
		const floorMaterial = new THREE.MeshBasicMaterial({
			map: floorTexture,
			side: THREE.DoubleSide,
			transparent: true,
			opacity: 0.5
		});
		
		floor = new THREE.Mesh(floorGeometry, floorMaterial);
		floor.rotation.x = -Math.PI / 2;
		updateFloorPosition();
		scene.add(floor);
	}
	
	function updateFloorPosition() {
		if (floor) {
			floor.position.y = -CONFIG.sphereRadius - 5;
		}
	}
	createCheckeredFloor();
	
	
	// --- (MODIFIED) 3. Create the Particle Ball ---
	let particleBall, particleMaterial;
	
	function regenerateParticleBall() {
		if (particleBall) {
			particleBall.geometry.dispose();
			particleBall.material.dispose();
			scene.remove(particleBall);
		}
		
		const geometry = new THREE.BufferGeometry();
		const positions = new Float32Array(CONFIG.particleCount * 3);
		const sizes = new Float32Array(CONFIG.particleCount);
		const randoms = new Float32Array(CONFIG.particleCount);
		
		const tempVec = new THREE.Vector3();
		const preset = COLOR_PRESETS[CONFIG.colorPreset];
		const shaders = ELEMENT_SHADERS[CONFIG.colorPreset];
		
		for (let i = 0; i < CONFIG.particleCount; i++) {
			tempVec.set(
				THREE.MathUtils.randFloatSpread(2),
				THREE.MathUtils.randFloatSpread(2),
				THREE.MathUtils.randFloatSpread(2)
			).normalize().multiplyScalar(CONFIG.sphereRadius);
			
			positions[i * 3] = tempVec.x;
			positions[i * 3 + 1] = tempVec.y;
			positions[i * 3 + 2] = tempVec.z;
			
			sizes[i] = Math.random() * 0.15 + 0.05;
			randoms[i] = Math.random();
		}
		
		geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
		geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
		geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
		
		particleMaterial = new THREE.ShaderMaterial({
			uniforms: {
				pointTexture: { value: particleTexture },
				uTime: { value: 0.0 },
				uNoiseAmount: { value: CONFIG.noise.amount },
				uNoiseSpeed: { value: CONFIG.noise.speed },
				uSphereRadius: { value: CONFIG.sphereRadius },
				uColorPrimary: { value: new THREE.Color(preset.primary) },
				uColorAccent: { value: new THREE.Color(preset.accent) },
				uColorGlow: { value: new THREE.Color(preset.glow) },
				// --- (MODIFIED) Explosion uniforms ---
				uExplosionProgress: { value: 0.0 },
				uExplosionStrength: { value: CONFIG.explosion.strength },
				uExplosionGravity: { value: CONFIG.explosion.gravity },
				uExplosionVariance: { value: CONFIG.explosion.variance },
				uFadeVariance: { value: CONFIG.explosion.fadeVariance },
			},
			vertexShader: shaders.vertex,
			fragmentShader: shaders.fragment,
			blending: THREE.AdditiveBlending,
			depthWrite: false,
			transparent: true,
		});
		
		particleBall = new THREE.Points(geometry, particleMaterial);
		scene.add(particleBall);
	}
	
	// --- Initial creation of the particle ball ---
	regenerateParticleBall();
	
	// --- (MODIFIED) GUI for real-time control ---
	const gui = new GUI();
	
	const ballFolder = gui.addFolder('Particle Ball');
	ballFolder.add(CONFIG, 'particleCount', 5000, 50000, 1000)
		.name('Particle Count')
		.onFinishChange(regenerateParticleBall);
	ballFolder.add(CONFIG, 'sphereRadius', 1, 20, 0.1)
		.name('Radius')
		.onFinishChange(() => {
			updateFloorPosition();
			regenerateParticleBall();
		});
	ballFolder.add(CONFIG, 'colorPreset', Object.keys(COLOR_PRESETS))
		.name('Element')
		.onChange(regenerateParticleBall);
	
	const noiseFolder = gui.addFolder('Organic Movement (Surface)');
	noiseFolder.add(CONFIG.noise, 'amount', 0, 5, 0.01).name('Amount').onChange(val => {
		if (particleMaterial) particleMaterial.uniforms.uNoiseAmount.value = val;
	});
	noiseFolder.add(CONFIG.noise, 'speed', 0, 1, 0.01).name('Speed').onChange(val => {
		if (particleMaterial) particleMaterial.uniforms.uNoiseSpeed.value = val;
	});
	
	const movementFolder = gui.addFolder('Global Movement (Drift)');
	movementFolder.add(CONFIG.ballMovement, 'amplitude', 0, 10, 0.1).name('Distance');
	movementFolder.add(CONFIG.ballMovement, 'speed', 0, 2, 0.01).name('Speed');
	
	const bloomFolder = gui.addFolder('Glow (Bloom)');
	bloomFolder.add(CONFIG.bloom, 'strength', 0, 3, 0.01).name('Strength').onChange(val => bloomPass.strength = val);
	bloomFolder.add(CONFIG.bloom, 'radius', 0, 2, 0.01).name('Radius').onChange(val => bloomPass.radius = val);
	bloomFolder.add(CONFIG.bloom, 'threshold', 0, 1, 0.01).name('Threshold').onChange(val => bloomPass.threshold = val);
	
	// --- (NEW) Interaction GUI ---
	const interactionFolder = gui.addFolder('Interaction');
	interactionFolder.add(CONFIG, 'flightSpeed', 1, 10, 0.1).name('Flight Speed');
	const explosionFolder = interactionFolder.addFolder('Explosion');
	explosionFolder.add(CONFIG.explosion, 'duration', 0.5, 5.0, 0.1).name('Duration (s)');
	explosionFolder.add(CONFIG.explosion, 'strength', 10, 150, 1).name('Force').onChange(val => {
		if (particleMaterial) particleMaterial.uniforms.uExplosionStrength.value = val;
	});
	explosionFolder.add(CONFIG.explosion, 'gravity', 0, 100, 1).name('Gravity').onChange(val => {
		if (particleMaterial) particleMaterial.uniforms.uExplosionGravity.value = val;
	});
	explosionFolder.add(CONFIG.explosion, 'variance', 0, 5, 0.1).name('Speed Variance').onChange(val => {
		if (particleMaterial) particleMaterial.uniforms.uExplosionVariance.value = val;
	});
	explosionFolder.add(CONFIG.explosion, 'fadeVariance', 0, 0.4, 0.01).name('Fade Variance').onChange(val => {
		if (particleMaterial) particleMaterial.uniforms.uFadeVariance.value = val;
	});
	
	// --- (MODIFIED) Interaction and State Management ---
	const raycaster = new THREE.Raycaster();
	const mouse = new THREE.Vector2(); // Will store normalized device coordinates
	const targetPosition = new THREE.Vector3();
	const targetPlane = new THREE.Plane(); // For 3D mouse projection
	const cameraDirection = new THREE.Vector3();
	let state = 'drifting'; // 'drifting', 'flying', 'exploding'
	let explosionStartTime = 0;
	
	function onMouseMove(event) {
		// Update mouse coordinates for raycasting
		mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
		mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
	}
	
	// <<< MODIFIED: This function is now fully implemented
	function onKeyDown(event) {
		// Trigger flight on spacebar press
		if (event.code === 'Space' && state === 'drifting') {
			event.preventDefault(); // Prevent page from scrolling
			
			// 1. Get the direction the camera is looking
			camera.getWorldDirection(cameraDirection);
			
			// 2. Create a plane at the ball's current position, facing the camera.
			// The plane's normal must point TOWARDS the camera for the ray to intersect it.
			const planeNormal = cameraDirection.clone().negate();
			targetPlane.setFromNormalAndCoplanarPoint(planeNormal, particleBall.position);
			
			// 3. Cast a ray from the camera through the mouse position
			raycaster.setFromCamera(mouse, camera);
			
			// 4. Find where the ray hits the plane
			if (raycaster.ray.intersectPlane(targetPlane, targetPosition)) {
				// We have a 3D target!
				state = 'flying';
				flightStart = clock.getElapsedTime();
				flightStartPosition.copy(particleBall.position);
				//controls.enabled = false; // Disable camera controls during flight
			}
		}
	}
	
	// <<< MODIFIED: This function now resets the camera target
	function respawnBall() {
		// Pick a random element
		const elements = Object.keys(COLOR_PRESETS);
		CONFIG.colorPreset = elements[Math.floor(Math.random() * elements.length)];
		
		// Pick a random size
		CONFIG.sphereRadius = THREE.MathUtils.randFloat(6, 14);
		
		// Regenerate the ball with new settings
		regenerateParticleBall();
		updateFloorPosition();
		
		// Reset its position and state
		particleBall.position.set(0, 0, 0);
		controls.target.set(0, 0, 0); // <<< ADDED: Reset camera target as well
		state = 'drifting';
		
		// Update the GUI to show the new random values
		gui.updateDisplay();
		controls.enabled = true; // Re-enable camera controls
	}
	
	// --- Controls & Animation ---
	const controls = new OrbitControls(camera, renderer.domElement);
	controls.enableDamping = true;
	controls.dampingFactor = 0.05;
	controls.minDistance = 15;
	controls.maxDistance = 100;
	controls.target.set(0, 0, 0);
	
	const clock = new THREE.Clock();
	
	function animate() {
		requestAnimationFrame(animate);
		const elapsedTime = clock.getElapsedTime();
		const deltaTime = clock.getDelta();
		
		if (particleBall && particleMaterial) {
			particleMaterial.uniforms.uTime.value = elapsedTime;
			
			if (state === 'drifting') {
				const moveSpeed = CONFIG.ballMovement.speed;
				const moveAmplitude = CONFIG.ballMovement.amplitude;
				particleBall.position.x = Math.sin(elapsedTime * moveSpeed) * moveAmplitude;
				particleBall.position.y = Math.sin(elapsedTime * moveSpeed * 0.8) * moveAmplitude * 0.4;
				particleBall.position.z = Math.cos(elapsedTime * moveSpeed * 1.2) * moveAmplitude;
				particleBall.rotation.y = elapsedTime * 0.05;
				
				//controls.target.copy(particleBall.position);
				
				controls.update();
			}
			else if (state === 'flying') {
				const flightTime = (elapsedTime - flightStart) * CONFIG.flightSpeed;
				const t = Math.min(flightTime / 1.0, 1.0); // 1.0 sec normalized
				
				// Smooth interpolation
				particleBall.position.lerpVectors(flightStartPosition, targetPosition, t);
				
				if (t >= 1.0) {
					state = 'exploding';
					explosionStartTime = elapsedTime;
				}
				controls.update();
			}
			else if (state === 'exploding') {
				const progress = (elapsedTime - explosionStartTime) / CONFIG.explosion.duration;
				particleMaterial.uniforms.uExplosionProgress.value = Math.min(progress, 1.0);
				
				// Wait a bit longer for particles to fade out completely before respawning
				if (progress > 1.5) {
					respawnBall();
				}
				controls.update();
			}
		}
		
		composer.render();
	}
	
	// --- Handle Window Resizing ---
	window.addEventListener('resize', () => {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
		composer.setSize(window.innerWidth, window.innerHeight);
		renderer.setPixelRatio(window.devicePixelRatio);
	});
	
	// --- (NEW) Add event listeners for mouse move and keydown ---
	window.addEventListener('mousemove', onMouseMove);
	window.addEventListener('keydown', onKeyDown);
	
	animate();
</script>
</body>
</html>
